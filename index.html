<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop</title>
    <style>
		* { padding: 0; margin: 0; }
		canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>

<script src="./victor.js"></script>

<script>

// ########################
// Projectile Class
// ########################

function Projectile(x, y, dx, dy) {
	this.x = x;
	this.y = y;
	this.radius = 2;
	this.dx = dx;
	this.dy = dy;
	
	this.offScreen = false;
	this.remove = false;

	this.color = "#0000FF";
	this.damage = 10;
}

Projectile.prototype.update = function () {
	this.x += this.dx;
	this.y += this.dy;

	if (this.x < -this.radius || this.x > canvas.width + this.radius ||
		this.y < -this.radius || this.y > canvas.height + this.radius) {
		this.offScreen = true;
	}
}

Projectile.prototype.draw = function (ctx) {
	ctx.beginPath();
	ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
	ctx.fillStyle = this.color;
	ctx.fill();
	ctx.closePath();
}

// ########################
// Bullet Class
// ########################

function Bullet(x, y, dx, dy) {
	Projectile.call(this, x, y, dx, dy);

	this.color = "#0000FF";
	this.damage = 2;
}

Bullet.prototype = Object.create(Projectile.prototype);
Bullet.prototype.constructor = Bullet;

// ########################
// HomingBullet Class
// ########################

function HomingBullet(x, y, dx, dy, player) {
	Bullet.call(this, x, y, dx, dy);
  this.player = player;
  
  this.speed = dy;
  this.dtheta = Math.PI / 400;
  this.v = new Victor(0, dy);

	this.color = "#0066FF";
	this.damage = 2;
}

HomingBullet.prototype = Object.create(Bullet.prototype);
HomingBullet.prototype.constructor = HomingBullet;

HomingBullet.prototype.update = function () {
  var pp = new Victor(this.player.x, this.player.y);
  var pb = new Victor(this.x, this.y);
  var d = pp.clone().subtract(pb);
  //var btheta = this.v.angle();
  //var ptheta = pp.angle();
  var theta = d.angle() - this.v.angle();
  
  if (theta < -Math.PI) theta += 2 * Math.PI;
  if (theta > Math.PI) theta -= 2 * Math.PI;
  
  if (Math.abs(theta) < this.dtheta) {
    this.v.rotateTo(d.angle());
  } else { 
    this.v.rotate(theta < 0 ? -this.dtheta : this.dtheta);
  }
 
  //this.v.rotateTo((pp.clone().subtract(pb)).angle());
  //console.log(pp.angle() + "/" + this.v.angle());
  
  this.x += this.v.x;
  this.y += this.v.y;

	if (this.x < -this.radius || this.x > canvas.width + this.radius ||
		this.y < -this.radius || this.y > canvas.height + this.radius) {
		this.offScreen = true;
	}
}

// ########################
// StraightBullet Class
// ########################

function StraightBullet(x, y, dx, dy) {
	Bullet.call(this, x, y, dx, dy);

	this.color = "#00FFFF";
	this.damage = 2;
}

StraightBullet.prototype = Object.create(Bullet.prototype);
StraightBullet.prototype.constructor = StraightBullet;

// ########################
// Powerup Class
// ########################

function Powerup() {
	this.x = Math.random() * canvas.width;
	this.y = Math.random() * canvas.height;
	this.radius = 4;
	this.dx = Math.random() * 2 - 1;
	this.dy = Math.random() * 2 - 1;
	this.color = "yellow";

	this.offScreen = false;
	this.remove = false;

	this.aliveTime = 4000;
	this.lastAlive = (new Date()).getTime();
}

Powerup.prototype.update = function () {
	this.x += this.dx;
	this.y += this.dy;

	if (this.x < this.radius || this.x > canvas.width - this.radius) {
		this.dx *= -1;
	}

	if (this.y < this.radius || this.y > canvas.height - this.radius) {
		this.dy *= -1;
	}

	if (this.lastAlive + this.aliveTime < (new Date()).getTime()) {
		this.remove = true;
	}
}

Powerup.prototype.draw = function (ctx) {
	ctx.beginPath();
	ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
	ctx.fillStyle = this.color;
	ctx.fill();
	ctx.closePath();
}

Powerup.prototype.activate = function () {
	this.remove = true;
}

// ########################
// FireRatePowerup Class
// ########################

function FireRatePowerup() {
	Powerup.call(this);
	
	this.color = "#FF8800";
}

FireRatePowerup.prototype = Object.create(Powerup.prototype);
FireRatePowerup.prototype.constructor = FireRatePowerup;

FireRatePowerup.prototype.activate = function (player) {
	this.remove = true;
	player.weapon.increaseROF(20);
}

// ########################
// BulletSpeedPowerup Class
// ########################

function BulletSpeedPowerup() {
	Powerup.call(this);
	
	this.color = "#CCFF00";
}

BulletSpeedPowerup.prototype = Object.create(Powerup.prototype);
BulletSpeedPowerup.prototype.constructor = BulletSpeedPowerup;

BulletSpeedPowerup.prototype.activate = function (player) {
	this.remove = true;
	player.weapon.increaseBulletSpeed(20);
}

// ########################
// HPPowerup Class
// ########################

function HPPowerup() {
	Powerup.call(this);
	
	this.color = "#FF00FF";
}

HPPowerup.prototype = Object.create(Powerup.prototype);
HPPowerup.prototype.constructor = HPPowerup;

HPPowerup.prototype.activate = function (player) {
	this.remove = true;
	
  player.hp += 10;
  if (player.hp > player.maxhp)
    player.hp = player.maxhp;
}

// ########################
// PlayerSpeedPowerup Class
// ########################

function PlayerSpeedPowerup() {
	Powerup.call(this);
	
	this.color = "#00FF00";
}

PlayerSpeedPowerup.prototype = Object.create(Powerup.prototype);
PlayerSpeedPowerup.prototype.constructor = PlayerSpeedPowerup;

PlayerSpeedPowerup.prototype.activate = function (player) {
	this.remove = true;
	
  player.increaseSpeed(10);
}

// ########################
// PlayerAccelPowerup Class
// ########################

function PlayerAccelPowerup() {
	Powerup.call(this);
	
	this.color = "#00FFFF";
}

PlayerAccelPowerup.prototype = Object.create(Powerup.prototype);
PlayerAccelPowerup.prototype.constructor = PlayerAccelPowerup;

PlayerAccelPowerup.prototype.activate = function (player) {
	this.remove = true;
	
  player.increaseAccel(10);
}

// ########################
// Weapon Class
// ########################

function Weapon() {
	this.dx = 0;
	this.dy = 0;

	this.lastFire = 0;
	this.fireDelay = 1000;
}

Weapon.prototype.fire = function (projectiles, x, y) { }

Weapon.prototype.increaseROF = function (pct) {
	this.fireDelay /= (1 + pct / 100);
}

Weapon.prototype.increaseBulletSpeed = function (pct) {
	this.dx *= (1 + pct / 100);
	this.dy *= (1 + pct / 100);
}

// ########################
// WeaponSingleShot Class
// ########################

function WeaponSingleShot() {
	Weapon.call(this);
	
	this.dx = 0;
	this.dy = -2;

	this.lastFire = 0;
	this.fireDelay = 600;
}

WeaponSingleShot.prototype = Object.create(Weapon.prototype);
WeaponSingleShot.prototype.constructor = WeaponSingleShot;

WeaponSingleShot.prototype.fire = function (projectiles, x, y) {
	if (this.lastFire + this.fireDelay < (new Date()).getTime()) {
		var p = new Projectile(x, y, this.dx, this.dy);

		projectiles.push(p);
		this.lastFire = (new Date()).getTime();
	}
}

// ########################
// WeaponMultiShot Class
// ########################

function WeaponMultiShot() {
	Weapon.call(this);
	
	this.dx = 0;
	this.dy = -2;
	this.spread = 20;
	
	this.lastFire = 0;
	this.fireDelay = 1500;
}

WeaponMultiShot.prototype = Object.create(Weapon.prototype);
WeaponMultiShot.prototype.constructor = WeaponMultiShot;

WeaponMultiShot.prototype.fire = function (projectiles, x, y) {
	if (this.lastFire + this.fireDelay < (new Date()).getTime()) {
		projectiles.push(new Projectile(x - this.spread, y, this.dx, this.dy));
		projectiles.push(new Projectile(x, y, this.dx, this.dy));
		projectiles.push(new Projectile(x + this.spread, y, this.dx, this.dy));

		this.lastFire = (new Date()).getTime();
	}
}

// ########################
// WeaponSpreadShot Class
// ########################

function WeaponSpreadShot() {
	Weapon.call(this);
	
	//this.dx = 0.8;
	this.dy = -2;
	this.angle = Math.PI/10;
	
	this.lastFire = 0;
	this.fireDelay = 1500;
}

WeaponSpreadShot.prototype = Object.create(Weapon.prototype);
WeaponSpreadShot.prototype.constructor = WeaponSpreadShot;

WeaponSpreadShot.prototype.fire = function (projectiles, x, y) {
	if (this.lastFire + this.fireDelay < (new Date()).getTime()) {
		projectiles.push(new Projectile(x, y, -this.dy * Math.tan(this.angle), this.dy));
		projectiles.push(new Projectile(x, y, 0, this.dy));
		projectiles.push(new Projectile(x, y, this.dy * Math.tan(this.angle), this.dy));

		this.lastFire = (new Date()).getTime();
	}
}

// ########################
// Player Class
// ########################

function Player(x, y) {
	this.radius = 10;
	this.x = x;
	this.y = y;
	this.dx = 0;		// Current speed
	this.dy = 0;
	this.ax = 0.08;		// Acceleration
	this.ay = 0.08;
	this.maxax = 0.15;	// Max acceleration possible with powerups
	this.maxay = 0.15;
	this.maxdx = 1.8;	// Current max speed
	this.maxdy = 1.8;
	this.limitdx = 4;	// Highest max speed you can get via powerups
	this.limitdy = 4;
  
	this.maxhp = 100;
	this.hp = this.maxhp;

	this.weapons = [];

	this.weapons.push(new WeaponSingleShot());
	this.weapons.push(new WeaponMultiShot());
	this.weapons.push(new WeaponSpreadShot());

	this.weapon = this.weapons[0];

	this.color = "#00FF00";
	this.dead = false;
}

Player.prototype.weaponSelect = function (i) {
	this.weapon = this.weapons[i];
}

Player.prototype.update = function () {
	if (rightPressed) {
		this.dx += this.ax;
		if (this.dx > this.maxdx) this.dx = this.maxdx;
	} else if (leftPressed) {
		this.dx -= this.ax;
		if (this.dx < -this.maxdx) this.dx = -this.maxdx;
	} else {
		if (Math.abs(this.dx) < this.ax) {
			this.dx = 0;
		} else {
			this.dx -= Math.sign(this.dx) * this.ax;
		}
	}
	
	if (this.x > canvas.width - this.radius) {
		this.dx = 0;
		this.x = canvas.width - this.radius;
	} else if (this.x < this.radius) {
		this.dx = 0;
		this.x = this.radius;
	}
	
	this.x += this.dx;
	
	
	if (downPressed) {
		this.dy += this.ay;
		if (this.dy > this.maxdy) this.dy = this.maxdy;
	} else if (upPressed) {
		this.dy -= this.ay;
		if (this.dy < -this.maxdy) this.dy = -this.maxdy;
	} else {
		if (Math.abs(this.dy) < this.ay) {
			this.dy = 0;
		} else {
			this.dy -= Math.sign(this.dy) * this.ay;
		}
	}

	if (this.y > canvas.height - this.radius) {
		this.dy = 0;
		this.y = canvas.height - this.radius;
	} else if (this.y < this.radius) {
		this.dy = 0;
		this.y = this.radius;
	}
	
	this.y += this.dy;
	
	
	if (this.hp <= 0) {
		this.dead = true;
	}
}

Player.prototype.draw = function (ctx) {
	ctx.beginPath();
	ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
	ctx.fillStyle = this.dead ? "#000000" : this.color;
	ctx.fill();
	ctx.closePath();
}

Player.prototype.fire = function (projectiles) {
	this.weapon.fire(projectiles, this.x, this.y);
}

Player.prototype.increaseSpeed = function (pct) {
  this.maxdx *= (1 + pct/100);  
  if (this.maxdx > this.limitdx) this.maxdx = this.limitdx;
    
  this.maxdy *= (1 + pct/100);  
  if (this.maxdy > this.limitdy) this.maxdy = this.limitdy;  
}

Player.prototype.increaseAccel = function (pct) {
  this.ax *= (1 + pct/100);  
  if (this.ax > this.maxax) this.ax = this.maxax;
    
  this.ay *= (1 + pct/100);  
  if (this.ay > this.maxay) this.ay = this.maxay;  
}

// ########################
// EnemyAI Class
// ########################

function EnemyAI(enemy) {
	this.dx = 2 + 0.5 * (2 * Math.random() - 1);
	this.dy = 0;
	this.bulletSpeedAvg = 2;
	this.bulletSpeedSpread = 0.5;

	this.enemy = enemy;

	this.direction = "right";
}

EnemyAI.prototype.move = function () {
  if (this.direction === "right") {
		if (this.enemy.x < canvas.width - this.enemy.radius) {
			this.enemy.x += this.dx;
		} else {
			this.direction = "left";
		} 
	}

	if (this.direction === "left") {
		if (this.enemy.x > this.enemy.radius) {
			this.enemy.x -= this.dx;
		} else {
			this.direction = "right";
		}
	}
   
	this.enemy.tryFire(
		this.enemy.x,
		this.enemy.y,
		0,
		this.bulletSpeedAvg + this.bulletSpeedSpread * (2 * Math.random() - 1)
	);
}

// ########################
// EnemyAICircle Class
// ########################

function EnemyAICircle(enemy, cx, cy) {
	this.cx = cx;
	this.cy = cy;  
	this.dcx = 0.5;
	this.dcy = 0;

	this.theta = 0;
	this.radius = 50;
	this.dtheta = Math.PI / 100;
	this.enemy = enemy;
}

EnemyAICircle.prototype.move = function () {
	this.theta += this.dtheta;

	this.cx += this.dcx;
	this.cy += this.dcy;
  
	this.enemy.x = this.cx + this.radius * Math.cos(this.theta);
	this.enemy.y = this.cy + this.radius * Math.sin(this.theta);
  
	if (this.enemy.x > canvas.width - this.enemy.radius || this.enemy.x < this.enemy.radius) {
		this.dcx *= -1;
		this.dtheta *= -1;
	}
	
	if (this.enemy.y > canvas.height - this.enemy.radius || this.enemy.y < this.enemy.radius) {
		this.dcy *= -1;
		this.dtheta *= -1;
	}

	this.enemy.tryFire(this.enemy.x, this.enemy.y, 0, 2);
}

// ########################
// EnemyAIPath Class
// ########################

function EnemyAIPath(enemy, speed, path) {
	this.enemy = enemy;
	this.speed = speed;
	this.path = path || [];
	this.p0i = 0;
	this.p1i = 1;
	this.t = 0;
}

EnemyAIPath.prototype.addPoint = function (p) {
	this.path.push(p);
	return this;
}

EnemyAIPath.prototype.move = function () {
	if (this.path.length == 0) {
		this.enemy.x = 0;
		this.enemy.y = 0;
		return;
	} else if (this.path.length == 1) {
		this.enemy.x = path[0].x;
		this.enemy.y = path[0].y;
		return;
	}
	
	var p0 = this.path[this.p0i];
	var p1 = this.path[this.p1i];
	var d = p1.clone().subtract(p0).length();
	var dt = this.speed / d;
	
	this.t += dt;
	
	if (this.t >= 1) {
		while (this.t >= 1) this.t--;
		
		if (this.p1i == this.path.length - 1) {
      // If we're at the end of the path. change directions
			this.p0i = this.path.length - 1;
			this.p1i = this.path.length - 2;
		} else if (this.p1i == 0) {
      // If we're at the beginning of the path change directions
			this.p0i = 0;
			this.p1i = 1;
		} else {
      // Step forward depending on which direction we're moving
			if (this.p0i < this.p1i) {
				this.p0i++;
				this.p1i++;
			} else {
				this.p0i--;
				this.p1i--;
			}
		}
		
		p0 = this.path[this.p0i];
		p1 = this.path[this.p1i];
	}
	
  // Interpolate between points
	var p = p0.clone().mix(p1, this.t);
	this.enemy.x = p.x;
	this.enemy.y = p.y;
	
	this.enemy.tryFire(this.enemy.x, this.enemy.y, 0, 2);
}
	
// ########################
// Enemy Class
// ########################

function Enemy(x, y, dx, dy) {
	this.radius = 10;
	this.x = x;
	this.y = y;
	this.dx = dx;
	this.dy = dy;
	this.direction = "right";
	this.lastEnemyFire = (new Date()).getTime();
	this.enemyFireDelay = 1000;
	this.score = 100;

	this.ai = new EnemyAI(this);

	this.color = "#FF0000";
	this.hp = 100;
	this.dead = false;
}

Enemy.prototype.update = function () {
	if (this.hp <= 0) {
		this.dead = true;
	}
  
  this.ai.move();
}

Enemy.prototype.draw = function (ctx) {
	ctx.save();
	ctx.beginPath();

	ctx.globalAlpha = this.hp / 200 + 0.5;
	ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
	ctx.fillStyle = this.color;
	ctx.fill();

	ctx.closePath();
	ctx.restore();
}

Enemy.prototype.tryFire = function (x, y, dx, dy) {
	if (this.lastEnemyFire + this.enemyFireDelay < (new Date()).getTime()) {
		this.fire(x, y, dx, dy);
		this.lastEnemyFire = (new Date()).getTime();
	}
}

Enemy.prototype.fire = function (x, y, dx, dy) {
	enemyProjectiles.push(new StraightBullet(x, y, dx, dy));
}

// ########################
// EnemyCircle Class
// ########################

function EnemyCircle(x, y, dx, dy){
  Enemy.call(this, x, y, dx, dy)
  this.ai = new EnemyAICircle(this, x, y);
  
  this.score = 200;
  this.color = "#FF9900";
}

EnemyCircle.prototype = Object.create(Enemy.prototype);
EnemyCircle.prototype.constructor = EnemyCircle;

EnemyCircle.prototype.fire = function (x, y, dx, dy) {
	enemyProjectiles.push(new HomingBullet(x, y, dx, dy, player));
}
// ########################
// EnemyPath Class
// ########################

function EnemyPath(x, y, dx, dy){
  Enemy.call(this, x, y, dx, dy)
  this.ai = new EnemyAIPath(this, 1)
	.addPoint(new Victor(50, 50))
	.addPoint(new Victor(200, 50))
	.addPoint(new Victor(200, 200))
	.addPoint(new Victor(400, 50));
  
  this.score = 200;
  this.color = "#6600FF";
}

EnemyPath.prototype = Object.create(Enemy.prototype);
EnemyPath.prototype.constructor = EnemyPath;


// #########################
// Main
// #########################

var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");

var rightPressed = false;
var leftPressed = false;
var upPressed = false;
var downPressed = false;
var spacePressed = false;

var collideDelay = 100;
var lastCollide = (new Date()).getTime();

var lastpowerup = 0;
var powerupdelay = 2000;

var lastPlayerFire = 0;
var playerFireDelay = 400;

var player = new Player(canvas.width / 2, 3 * canvas.height / 4);

var playerProjectiles = [];
var enemyProjectiles = [];
var enemies = [];
var powerups = [];

var gameState = "game";
var score = 0;

enemies.push(new Enemy(10, 50, 2, 0));
enemies.push(new Enemy(50, 80, 1.5, 0));
enemies.push(new Enemy(100, 120, 0, 0));
enemies.push(new EnemyCircle(200, 40, 0, 0));
enemies.push(new EnemyPath(200, 40, 0, 0));

document.addEventListener("keydown", keyDownHandler, false);
document.addEventListener("keyup", keyUpHandler, false);

function collisionDetection() {
	for (var i = 0; i < enemies.length; i++) {
		for (var j = 0; j < playerProjectiles.length; j++) {
			var rect1 = enemies[i];
			var rect2 = playerProjectiles[j];
			if ((rect1.x - rect1.radius) < (rect2.x + rect2.radius) &&
				(rect1.x + rect1.radius) > (rect2.x - rect2.radius) &&
				(rect1.y - rect1.radius) < (rect2.y + rect2.radius) &&
				(rect1.y + rect1.radius) > (rect2.y - rect2.radius))
			{
				var e = enemies[i];
				var p = playerProjectiles[j];
				p.remove = true;
				e.hp -= p.damage;
			}
		}

		var rect1 = player;
		var rect2 = enemies[i];

		if ((rect1.x - rect1.radius) < (rect2.x + rect2.radius) &&
			(rect1.x + rect1.radius) > (rect2.x - rect2.radius) &&
			(rect1.y - rect1.radius) < (rect2.y + rect2.radius) &&
			(rect1.y + rect1.radius) > (rect2.y - rect2.radius)) 
    {
			if (lastCollide + collideDelay < (new Date()).getTime()) {
				player.hp -= 10;
				player.update();
				lastCollide = (new Date()).getTime();
			}
		}
	}

	for (var j = 0; j < enemyProjectiles.length; j++) {
		var rect1 = player;
		var rect2 = enemyProjectiles[j];
		if ((rect1.x - rect1.radius) < (rect2.x + rect2.radius) &&
			(rect1.x + rect1.radius) > (rect2.x - rect2.radius) &&
			(rect1.y - rect1.radius) < (rect2.y + rect2.radius) &&
			(rect1.y + rect1.radius) > (rect2.y - rect2.radius))
		{
			var proj = enemyProjectiles[j];
			proj.remove = true;
			player.hp -= proj.damage;
		}
	}

	for (var j = 0; j < powerups.length; j++) {
		var rect1 = player;
		var rect2 = powerups[j];
		if ((rect1.x - rect1.radius) < (rect2.x + rect2.radius) &&
			(rect1.x + rect1.radius) > (rect2.x - rect2.radius) &&
			(rect1.y - rect1.radius) < (rect2.y + rect2.radius) &&
			(rect1.y + rect1.radius) > (rect2.y - rect2.radius))
		{
			var pow = powerups[j];
			pow.activate(player);

			if (pow instanceof BulletSpeedPowerup) {
				console.log("Bullet speed powerup aquired");
			} else if (pow instanceof FireRatePowerup) {
				console.log("Fire rate powerup aquired");
			} else if (pow instanceof HPPowerup) {
				console.log("HP powerup aquired");
			} else if (pow instanceof PlayerSpeedPowerup) {
				console.log("Player speed powerup aquired");      
			} else if (pow instanceof PlayerAccelPowerup) {
				console.log("Player acceleration powerup aquired");      
			}
		}
	}
}

function keyDownHandler(e) {
	if (e.keyCode == 68) {
		rightPressed = true;
	}

	if (e.keyCode == 87) {
		upPressed = true;
	}

	if (e.keyCode == 83) {
		downPressed = true;
	}

	if (e.keyCode == 65) {
		leftPressed = true;
	}

	if (e.keyCode == 32) {
		spacePressed = true;
	}

	if (e.keyCode == 49) {
		player.weaponSelect(0);
	}

	if (e.keyCode == 50) {
		player.weaponSelect(1);
	}

	if (e.keyCode == 51) {
		player.weaponSelect(2);
	}
}
function keyUpHandler(e) {
	if (e.keyCode == 68) {
		rightPressed = false;
	}

	if (e.keyCode == 87) {
		upPressed = false;
	}

	if (e.keyCode == 83) {
		downPressed = false;
	}

	if (e.keyCode == 65) {
		leftPressed = false;
	}

	if (e.keyCode == 32) {
		spacePressed = false;
	}
}

function draw() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);

	ctx.fillStyle = "black";
	ctx.fillRect(0, 0, canvas.width, canvas.height);

	if (gameState === "game") {
		collisionDetection();

		player.update();
		player.draw(ctx);

		for (var i in playerProjectiles) {
			var p = playerProjectiles[i];

			if (p.offScreen || p.remove) {
				playerProjectiles.splice(i, 1);
				continue;
			}

			p.update();
			p.draw(ctx);
		}

		for (var i in enemyProjectiles) {
			var p = enemyProjectiles[i];

			if (p.offScreen || p.remove) {
				enemyProjectiles.splice(i, 1);
				continue;
			}

			p.update();
			p.draw(ctx);
		}

		for (var i in enemies) {
			var e = enemies[i];

			if (e.dead) {
				enemies.splice(i, 1);
        score += e.score;
				continue;
			}
      
			e.update();
			e.draw(ctx);
		}

		for (var i in powerups) {
			var p = powerups[i];

			if (p.offScreen || p.remove) {
				powerups.splice(i, 1);
				continue;
			}

			p.update();
			p.draw(ctx);
		}

		if (lastpowerup + powerupdelay < (new Date()).getTime()) {
			var randompowerup = Math.floor((Math.random() * 5) + 1);
			var p;
      
			if (randompowerup == 1) {
				p = new BulletSpeedPowerup();
			} else if (randompowerup == 2) {
				p = new FireRatePowerup();
			} else if (randompowerup == 3) {
				p = new HPPowerup();
			} else if (randompowerup == 4) {
				p = new PlayerSpeedPowerup();
			} else if (randompowerup == 5) {
				p = new PlayerAccelPowerup();
			}
      
			powerups.push(p);
			lastpowerup = (new Date()).getTime();
		}

		console.log("pp: " + playerProjectiles.length + " | " +
			"ep: " + enemyProjectiles.length + " | " +
			"e: " + enemies.length + " | " +
			"p: " + powerups.length);

		if (spacePressed) {
			player.fire(playerProjectiles);
		}
    
		ctx.font = "16px sans serif";
		ctx.fillStyle = "white";
		ctx.textAlign = "left";
		ctx.fillText("HP = " + player.hp + "/" + player.maxhp, 0, 16);
		ctx.fillText("Score = " + score, 0, 32);

		if (player.hp <= 0) {
			gameState = "gameOver";
		}
	} else if (gameState === "gameOver") {
		ctx.font = "48px sans serif";
		ctx.fillStyle = "white";
		ctx.textAlign = "center";
		ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2);
	}
}

setInterval(draw, 10);
</script>

</body>
</html>